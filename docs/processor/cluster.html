<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>cluster.py</title>
  <link rel="stylesheet" href="../pycco.css">
</head>
<body>
<div id="background"></div>
<div id='container'>
  
  <div class='section'>
    <div class='docs'><h1>cluster.py</h1></div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      <p>def log(st):
    s = " ".join(['--', str(datetime.datetime.utcnow()), '--', st])
    f = open(str(os.getpid()) + '-cluster.log', 'a')
    f.write(s + "\n")
    f.close()
    print s</p>
<h1>TODO Validate ARGUMENTS HERE</h1>
<p>if len(sys.argv) &lt; 3:
    print <strong>doc</strong>
    sys.exit(1)</p>
<p>Xfile = sys.argv[1]</p>
<p>K = int(sys.argv[2])</p>
<p>log("Loading features")</p>
<p>sK = 0
eK = 0
if len(sys.argv) == 4:
    rK = sys.argv[3].split(":")
    if len(rK) == 1:
        try:
            eK = int(rK[0])
        except ValueError, TypeError:
            pass
    if len(rK) == 2:
        try:
            sK = int(rK[0])
        except ValueError, TypeError:
            pass
        try:
            eK = int(rK[1])
        except ValueError, TypeError:
            pass</p>
<p>ft = loadtxt(Xfile, skiprows=sK)</p>
<p>if eK &lt; 3:
    eK = len(ft)
if eK &gt; len(ft):
    eK = len(ft)
if sK &lt; 0:
    sK = 0</p>
<p>if eK &lt;= sK:
    log("Range is empty")
    sys.exit(1)</p>
<p>feat = ft[0:eK - sK, :]</p>
<p>log("Calculating Clusters for items %d through %d (inclusive)" % (sK + 1, eK))</p>
<h1>Normalize the features (Still have some doubts about the quality of</h1>
<h1>results of this approach)</h1>
<h1>feat=whiten(feat)</h1>
<h1>The use of the Kmeans2 is giving crappy results as it is only running once.</h1>
<h1>centroids, labels=kmeans2(feat,K, minit='points', iter=10)</h1>
<h1>To use the Kmeans algorithm from scipy we get centroids and the variance and</h1>
<h1>the iter parameter is not the iterations but the number of times to</h1>
<h1>run kmeans</h1>
<p>centroids, variance = kmeans(feat, K, iter=100)</p>
<p>log(
    "Centroids and Variance Calculated... proceeding to calculate Labels and Distance Matrix")</p>
<h1>But for this is necessary to compute the labels from the centroids (distance)</h1>
<h1>from the features and the centroids.</h1>
<p>labels, distance = vq(feat, centroids)</p>
<p>log("Labels length: " + str(len(labels)))</p>
<p>outputCluster = open("cluster-" + Xfile, "w")
for k in range(len(labels)):
    outputCluster.write(str(k + 1) + " " + str(labels[k] + 1) + "\n")
outputCluster.close()</p>
<p>log("Clusters Exported to file clusters-...")</p>
<p>log("Starting Display")</p>
<h1>A partir dos centroids pode-se calcular a distância de cada documento a cada</h1>
<h1>um dos centroids com uma cor respectiva.</h1>
<h1>Se desenharmos horizontalmente os pontos com X a ser a data de</h1>
<h1>publicação e Y o cluster?</h1>
<h1>O ideal será talvez utilizar o tkinter e o Canvas</h1>
<p>from Tkinter import *</p>
<p>root = Tk()
root.title("Clustering " + str(len(labels)) + " examples in " +
           str(K) + " clusters")
largura = 1400
altura = 700
ex = 2
bsize = 3</p>
<p>wstep = (0.0 + largura) / (len(labels) + 1.0)
hstep = altura / K
print wstep
print hstep</p>
<p>c = Canvas(root, width=largura, height=altura + hstep / ex)
c.pack()</p>
<p>def sim(a, b):
    return dot(a, b) / math.sqrt(dot(a, a) * dot(b, b))</p>
<h1>Calculate Similarity matrix to improve speed</h1>
<p>distm = zeros((len(labels), len(labels)))
for i in range(0, len(labels)):
    for j in range(i, len(labels)):
        distm[i, j] = sim(feat[i, :], feat[j, :])
        distm[j, i] = distm[i, j]</p>
<p>log("Saving Similarity Matrix similarity-...")
savetxt("similarity-" + Xfile, distm)</p>
<h1>Start drawing...</h1>
<p>lcen = []
pcen = []
text = []
arcs = []</p>
<p>def drawBack():
    for i in range(1, K + 1):
        lcen.append(c.create_line(0, hstep * i, largura, hstep * i))</p>
<p>def drawPoints():
    for i in range(0, len(labels)):
        x = (i + 1) * wstep
        y = (labels[i] + 1) * hstep
        pcen.append(c.create_rectangle(x - bsize, y - bsize,
                                       x + bsize, y + bsize, fill='red'))
        text.append(
            c.create_text(x, y + 40 - 10 * (i % 4), text=str(i + sK + 1),
                          activefill='blue', font=('arial', 9)))</p>
<p>def drawArcs(event):
    for el in arcs:
        c.delete(el)
    thresholdArcs = s.get()
    for i in range(0, len(labels)):
        x = (i + 1) * wstep
        y = (labels[i] + 1) * hstep
        for old in range(0, i):
        #            if dist(feat[old,:] ,feat[i,:] )<thresholdArcs:
            if distm[old, i] > thresholdArcs:
                oldx = (old + 1) * wstep
                oldy = (labels[old] + 1) * hstep
                if  abs(oldy - y) &gt; 2:
                    arcs.append(c.create_line(oldx, oldy, x, y,
                                              fill='gray', activefill='blue'))
                else:
                    arcs.append(c.create_arc(oldx, y - hstep / ex, x,
                                             y + hstep / ex, start=0,
                                             extent=180, outline='gray',
                                             activeoutline='blue',
                                             activewidth=2.0))
    for el in arcs:
        c.tag_lower(el)</p>
<p>s = Scale(root, from_=0.0, to=1.0, resolution=0.01, orient=HORIZONTAL,
          label='Minimum Document Similarity:', length=0.6 * largura)
s.bind("<ButtonRelease-1>", drawArcs)
s.pack()
s.set(0.9)</p>
<p>drawBack()
drawPoints()
drawArcs(None)</p>
<h1>import cProfile</h1>
<h1>cProfile.run('drawArcs(None)','drawArcs.prof')</h1>
<p>mainloop()</p>
<p>log("Done")</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span>   <span class="n">loadtxt</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">savetxt</span>
<span class="kn">from</span> <span class="nn">scipy.cluster.vq</span> <span class="kn">import</span>   <span class="n">vq</span><span class="p">,</span> <span class="n">kmeans</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">dot</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s">&#39;david&#39;</span>
<span class="n">__doc__</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">Performs k-means clustering on a matrix of features</span>

<span class="s">Input:</span>
<span class="s">        * A file with the features matrix MxN where M is the number of</span>
<span class="s">            observations and N is the number of features</span>
<span class="s">        * The desired number of clusters K</span>
<span class="s">        * The range of features to work with</span>
<span class="s">            ex:</span>
<span class="s">                4 # means 0...3</span>
<span class="s">                4:10 # means elements 4...9</span>
<span class="s">                4: # means 4...</span>
<span class="s">                :7 # means 0....6</span>

<span class="s">                Attention that this range starts index at 0 while the</span>
<span class="s">                documents index start at 1 so 0 corresponds to 1</span>

<span class="s">Output:</span>
<span class="s">        A file with the indexes of the clusters</span>

<span class="s">Usage:</span>
<span class="s">        python cluster.py &lt;features.txt&gt; &lt;K&gt; &lt;range&gt;</span>

</pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  
</div>
</body>
